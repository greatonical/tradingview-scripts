//@version=6
indicator("Normal Confluence Overlay (Latched Plan)", overlay=true, max_lines_count=300, max_labels_count=300)

// ── Inputs
emaFastLen  = input.int(9,  "EMA Fast",  minval=1)
emaSlowLen  = input.int(21, "EMA Slow",  minval=1)
emaBaseLen  = input.int(200,"EMA Base",  minval=1)

rsiLen      = input.int(14, "RSI Length", minval=1, group="StochRSI")
kLen        = input.int(14, "Stoch K",    minval=1, group="StochRSI")
dLen        = input.int(3,  "Stoch D",    minval=1, group="StochRSI")
obLevel     = input.float(80, "OB", minval=0, maxval=100, group="StochRSI")
osLevel     = input.float(20, "OS", minval=0, maxval=100, group="StochRSI")

macdFast    = input.int(12, "MACD Fast",  minval=1, group="MACD")
macdSlow    = input.int(26, "MACD Slow",  minval=1, group="MACD")
macdSig     = input.int(9,  "MACD Signal",minval=1, group="MACD")

atrLen      = input.int(14, "ATR Length", minval=1, group="Volatility")
atrSpikeX   = input.float(1.75, "ATR Spike × Avg ATR", minval=1, group="Volatility")

showMAs     = input.bool(true, "Show EMA 50/200", group="Extra MAs")
ema50Len    = input.int(50,  "EMA 50", group="Extra MAs")
ema200Len   = input.int(200, "EMA 200", group="Extra MAs")

// Plan logic
resetOpposite = input.bool(true,  "Reset plan on opposite setup", group="Plan Reset")
resetTrendFlip= input.bool(false, "Reset plan on EMA trend flip", group="Plan Reset")
resetNow      = input.bool(false, "Reset now (toggle)",           group="Plan Reset")

// Take-profit %s & optional ATR stop
tpPct1 = input.float(0.25, "TP1 %", step=0.01, group="Plan Targets")
tpPct2 = input.float(0.50, "TP2 %", step=0.01, group="Plan Targets")
tpPct3 = input.float(0.75, "TP3 %", step=0.01, group="Plan Targets")
tpPct4 = input.float(1.00, "TP4 %", step=0.01, group="Plan Targets")
tpPct5 = input.float(1.25, "TP5 %", step=0.01, group="Plan Targets")
useFixedATR = input.bool(true,  "Use ATR-based Stop?", group="Plan Targets")
atrStopMult = input.float(1.5,  "Stop = Entry ± ATR×Mult", minval=0.1, step=0.1, group="Plan Targets")

// ── Core MAs / Ribbon
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
emaBase = ta.ema(close, emaBaseLen)
ribbonBull = emaFast > emaSlow

colBull = color.new(color.teal, 0)
colBear = color.new(color.rgb(128, 0, 0), 0) // safe "maroon" equivalent

pFast = plot(emaFast, "EMA Fast", color=ribbonBull ? colBull : colBear, linewidth=2)
pSlow = plot(emaSlow, "EMA Slow", color=ribbonBull ? color.new(colBull, 50) : color.new(colBear, 50), linewidth=2)
fill(pFast, pSlow, color=ribbonBull ? color.new(colBull, 80) : color.new(colBear, 80))

ema50  = ta.ema(close, ema50Len)
ema200 = ta.ema(close, ema200Len)
plot(showMAs ? ema50  : na, "EMA 50",  color=color.fuchsia)
plot(showMAs ? ema200 : na, "EMA 200", color=color.purple)

// ── StochRSI
rsi_src = ta.rsi(close, rsiLen)
k = ta.sma(ta.stoch(rsi_src, rsi_src, rsi_src, kLen), 1)
d = ta.sma(k, dLen)
kOB = k > obLevel
kOS = k < osLevel
kCrossUp = ta.crossover(k, d)
kCrossDn = ta.crossunder(k, d)

// ── MACD
macdLine  = ta.ema(close, macdFast) - ta.ema(close, macdSlow)
macdSigLn = ta.ema(macdLine, macdSig)
macdHist  = macdLine - macdSigLn
momUp     = macdHist > 0 and macdLine > macdSigLn
momDn     = macdHist < 0 and macdLine < macdSigLn

// ── Strong confluence (setup)
longSetup  = (emaFast > emaSlow) and momUp  and (kCrossUp or (kOS and k > d))
shortSetup = (emaFast < emaSlow) and momDn  and (kCrossDn or (kOB and k < d))

// ── Volatility (info)
atr = ta.atr(atrLen)
atrSpike = atr > atrSpikeX * ta.sma(atr, atrLen)
plotshape(atrSpike, title="Lightning", style=shape.flag, location=location.abovebar, size=size.tiny, color=color.orange, text="⚡")

// ── LATCHED PLAN (persists until reset)
var bool   inLong    = false
var bool   inShort   = false
var float  planEntry = na
var float  planStop  = na
var float  planTP1   = na
var float  planTP2   = na
var float  planTP3   = na
var float  planTP4   = na
var float  planTP5   = na

// reset helpers
emaFlip = ta.cross(emaFast, emaSlow)
needReset = false
needReset := resetNow or (resetOpposite and ((inLong and shortSetup) or (inShort and longSetup))) or (resetTrendFlip and emaFlip)

// clear plan when needed
if needReset
    inLong := false
    inShort := false
    planEntry := na
    planStop  := na
    planTP1 := na
    planTP2 := na
    planTP3 := na
    planTP4 := na
    planTP5 := na

// arm new plan when no active plan
if na(planEntry)
    if longSetup
        inLong := true
        inShort := false
        planEntry := close
        if useFixedATR
            planStop := planEntry - atr * atrStopMult
        planTP1 := planEntry * (1 + tpPct1/100.0)
        planTP2 := planEntry * (1 + tpPct2/100.0)
        planTP3 := planEntry * (1 + tpPct3/100.0)
        planTP4 := planEntry * (1 + tpPct4/100.0)
        planTP5 := planEntry * (1 + tpPct5/100.0)
        label.new(bar_index, low, "LONG", xloc=xloc.bar_index, yloc=yloc.belowbar, style=label.style_label_up, textcolor=color.white, color=colBull)
    else
        if shortSetup
            inShort := true
            inLong := false
            planEntry := close
            if useFixedATR
                planStop := planEntry + atr * atrStopMult
            planTP1 := planEntry * (1 - tpPct1/100.0)
            planTP2 := planEntry * (1 - tpPct2/100.0)
            planTP3 := planEntry * (1 - tpPct3/100.0)
            planTP4 := planEntry * (1 - tpPct4/100.0)
            planTP5 := planEntry * (1 - tpPct5/100.0)
            label.new(bar_index, high, "SHORT", xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_down, textcolor=color.white, color=colBear)

// ── Draw fixed levels (don’t move after armed)
var line lnE = na
var line lnS = na
var line ln1 = na
var line ln2 = na
var line ln3 = na
var line ln4 = na
var line ln5 = na

var label lbE = na
var label lbS = na
var label lb1 = na
var label lb2 = na
var label lb3 = na
var label lb4 = na
var label lb5 = na

drawHoriz(_oldLine, _y, _c) =>
    if not na(_oldLine)
        line.delete(_oldLine)
    line.new(bar_index, _y, bar_index, _y, xloc=xloc.bar_index, extend=extend.right, color=_c, width=2)

drawLab(_oldLab, _txt, _y, _c) =>
    if not na(_oldLab)
        label.delete(_oldLab)
    label.new(bar_index + 1, _y, _txt, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, textcolor=color.white, color=_c)

if barstate.islast and not na(planEntry)
    lnE := drawHoriz(lnE, planEntry, color.new(color.blue, 0))
    lbE := drawLab(lbE, "Entry: " + str.tostring(planEntry, format.mintick), planEntry, color.new(color.blue, 0))

    if not na(planStop)
        lnS := drawHoriz(lnS, planStop, color.new(color.red, 0))
        lbS := drawLab(lbS, "Invalidation: " + str.tostring(planStop, format.mintick), planStop, color.new(color.red, 0))

    if not na(planTP1)
        ln1 := drawHoriz(ln1, planTP1, color.new(color.orange, 0))
        lb1 := drawLab(lb1, "Exit 1: " + str.tostring(planTP1, format.mintick), planTP1, color.new(color.orange, 0))
    if not na(planTP2)
        ln2 := drawHoriz(ln2, planTP2, color.new(color.orange, 10))
        lb2 := drawLab(lb2, "Exit 2: " + str.tostring(planTP2, format.mintick), planTP2, color.new(color.orange, 10))
    if not na(planTP3)
        ln3 := drawHoriz(ln3, planTP3, color.new(color.orange, 20))
        lb3 := drawLab(lb3, "Exit 3: " + str.tostring(planTP3, format.mintick), planTP3, color.new(color.orange, 20))
    if not na(planTP4)
        ln4 := drawHoriz(ln4, planTP4, color.new(color.orange, 30))
        lb4 := drawLab(lb4, "Exit 4: " + str.tostring(planTP4, format.mintick), planTP4, color.new(color.orange, 30))
    if not na(planTP5)
        ln5 := drawHoriz(ln5, planTP5, color.new(color.orange, 40))
        lb5 := drawLab(lb5, "Exit 5: " + str.tostring(planTP5, format.mintick), planTP5, color.new(color.orange, 40))

// ── Right-hand ladder (info)
var label ladNow = na
var label ladS1  = na
var label ladS2  = na
var label ladS3  = na
var label ladR1  = na

sup1 = emaSlow
sup2 = emaBase
sup3 = ta.vwma(close, 50)
res1 = math.max(ema50, ema200)

mkRight(_txt, _y, _col) =>
    label.new(bar_index + 2, _y, _txt, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_right, color=_col, textcolor=color.white)

if barstate.islast
    if not na(ladNow)
        label.delete(ladNow)
    if not na(ladS1)
        label.delete(ladS1)
    if not na(ladS2)
        label.delete(ladS2)
    if not na(ladS3)
        label.delete(ladS3)
    if not na(ladR1)
        label.delete(ladR1)

    ladNow := mkRight(str.tostring(close, format.mintick), close, color.new(color.blue, 0))
    ladS1  := mkRight(str.tostring(sup1,  format.mintick), sup1,  color.new(color.teal, 20))
    ladS2  := mkRight(str.tostring(sup2,  format.mintick), sup2,  color.new(color.teal, 40))
    ladS3  := mkRight(str.tostring(sup3,  format.mintick), sup3,  color.new(color.teal, 60))
    ladR1  := mkRight(str.tostring(res1,  format.mintick), res1,  color.new(color.red, 30))